// Code generated by https://github.com/zhuharev/gen DO NOT EDIT.

package app

import (
	"bytes"
	"context"
	"crypto/sha256"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"time"

    "{{ $.project.GoModule }}/infrastructure"
{{ range (domainServices .project) }}
    {{ .Name }}RestDeliveryPkg "{{ $.project.GoModule }}/domain/{{ .Name }}/delivery/rest"
{{end}}

    echo "github.com/labstack/echo/v4"
    "github.com/minio/minio-go/v6"
    "github.com/disintegration/imaging"
)

func (a *App) registreHandlers() {
    a.registreRESTHandler()
    a.registreRPC()
    a.registreTelegram()
    a.registreSchema()
    //a.registreUploader()

    a.echo.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
        return func (ctx echo.Context) error {
            start := time.Now()
		    err:= next(ctx)
            a.Info("http request", zap.String("path", ctx.Request().URL.Path), zap.Duration("duration", time.Since(start)))
            return err
        }
    })

    a.echo.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
        return func (ctx echo.Context) error {
            cc := a.newContext(ctx)
		    return next(cc)
        }
    })
}

func (a *App) registreRESTHandler() {
    api := a.echo.Group("/api/v1")

{{ range (domainServices .project) }}
	{{ .Name }}RestDeliveryPkg.New(a.{{ .Name }}Uc).RegistreHandlers(api.Group("/{{ .Plural }}"))
{{end}}
}

func (a *App) registreRPC() {

}

func (a *App) registreTelegram() {

}

type UserIDer interface {
	UserID() (int, bool)
}


func (a *App) registreUploader() {
    {{ if .project.UploadServers }}
    location := "eu-central-1" //TODO: not used now
    // Initialize minio client object.
	minioClient, err := minio.New(a.cfg.Upload.Server, a.cfg.Upload.Key, a.cfg.Upload.Secret, true)
	if err != nil {
		log.Fatalln("new client", err)
	}
    {{ end }}
    {{ range .project.UploadServers}}
	{{ .Name }}BucketName := "{{ .Name }}"

	err = minioClient.MakeBucket({{ .Name }}BucketName, location)
	if err != nil {
		// Check to see if we already own this bucket (which happens if you run this twice)
		exists, errBucketExists := minioClient.BucketExists({{ .Name }}BucketName)
		if errBucketExists == nil && exists {
			log.Printf("We already own %s\n", {{ .Name }}BucketName)
		} else {
			log.Fatalln("make bucket", err)
		}
	} else {
		log.Printf("Successfully created %s\n", {{ .Name }}BucketName)
	}

    // make bucket public for static assets
	err = minioClient.SetBucketPolicy({{ .Name }}BucketName, `{
		"Version": "2012-10-17",
		"Statement": [
		  {
			"Action": "s3:GetObject",
			"Effect": "Allow",
			"Principal": {"AWS": "*"},
			"Resource": ["arn:aws:s3:::`+{{ .Name }}BucketName+`/*"],
			"Sid": "Public"
		  }
		]
	  }`)
	if err != nil {
		log.Fatalln("set bucket policy", err)
	}
    a.echo.POST("/api/v1/upload/{{ .Name }}", func(c echo.Context) error {
        //if ider, ok := c.(UserIDer); ok {
        //    if id, has := ider.UserID(); !has || id == 0 {
        //        return c.JSON(401, "auth required")
        //    }
        //} else {
        //    return c.JSON(401, "auth required")
        //}

		var src io.ReadCloser

		// try get file from body if request not multipart
		if !strings.HasPrefix(strings.ToLower(c.Request().Header.Get("Content-Type")), "multipart/form-data") {
			src = c.Request().Body
			defer src.Close()
		} else {
			file, err := c.FormFile("file")
			if err != nil {
				return c.JSON(500, map[string]string{"error": fmt.Sprintf("get form file: %s", err)})
			}

			src, err = file.Open()
			if err != nil {
				return c.JSON(500, err.Error())
			}
			defer src.Close()
		}

        h := sha256.New()

        rdr := io.TeeReader(src,h)

        img, err := imaging.Decode(rdr)
        if err != nil {
            return c.JSON(500, err.Error())
        }

        //TODO: check existence here / проверть что файл не существует в s3

        // validate
        {{ if .Validation }}
        {{ if .Validation.Image }}
        {{ if .Validation.Image.MinWidth }}
        if img.Bounds().Max.X < {{ .Validation.Image.MinWidth }} {
            return c.JSON(400, map[string]string{"error":fmt.Sprintf("min width: %d", {{ .Validation.Image.MinWidth }})})
        }
        {{ end }}
        {{ if .Validation.Image.MaxWidth }}
        if img.Bounds().Max.X > {{ .Validation.Image.MaxWidth }} {
            return c.JSON(400, map[string]string{"error":fmt.Sprintf("max width: %d", {{ .Validation.Image.MaxWidth }})})
        }
        {{ end }}
        {{ if .Validation.Image.MinHeight }}
        if img.Bounds().Max.Y < {{ .Validation.Image.MinHeight }} {
            return c.JSON(400, map[string]string{"error":fmt.Sprintf("min height: %d", {{ .Validation.Image.MinHeight }})})
        }
        {{ end }}
        {{ if .Validation.Image.MaxHeight }}
        if img.Bounds().Min.Y > {{ .Validation.Image.MaxHeight }} {
            return c.JSON(400, map[string]string{"error":fmt.Sprintf("max height: %d", {{ .Validation.Image.MaxHeight }})})
        }
        {{ end }}
        {{ end }}
        {{ end }}

        {{ if .Preprocess }}
        // thumbnail {{ if .Preprocess.Thumbnail }}
        img = imaging.Thumbnail(img, {{ .Preprocess.Thumbnail.Width }}, {{ .Preprocess.Thumbnail.Height }}, imaging.Lanczos)
        {{ end}}
        {{ end }}

        buf := bytes.NewBuffer(nil)
		err = imaging.Encode(buf, img, imaging.JPEG, imaging.JPEGQuality(75))
		if err != nil {
			return c.JSON(500, err.Error())
		}

        	// Upload the zip file
        objectName := fmt.Sprintf("%x.jpg", h.Sum(nil))
        contentType := "image/jpeg"

        //TODO: upload stream, set size -1
        // Upload the zip file with FPutObject
        _, err = minioClient.PutObject({{ .Name }}BucketName, objectName, buf, int64(buf.Len()), minio.PutObjectOptions{ContentType: contentType})
        if err != nil {
            return c.JSON(500, err.Error())
        }

        uri := fmt.Sprintf("https://%s/%s/%s", a.cfg.Upload.Server, {{ .Name }}BucketName, objectName)

        return c.JSON(200,map[string]string{"url": uri})
    })
    {{ end }}
}

func (a *App) registreSchema() {
    a.echo.GET("/api/v1", func(c echo.Context) error {
        c.Response().Header().Set(echo.HeaderContentType, echo.MIMEApplicationJSONCharsetUTF8)
        c.Response().WriteHeader(http.StatusOK)
        c.Response().Write(schema)
        return nil
    })
}

type ContextWithToken struct {
    echo.Context
    jwtGeneratorUc infrastructure.JwtGenerator
}

func (a *App) newContext(ctx echo.Context) *ContextWithToken {
    return &ContextWithToken{Context:ctx, jwtGeneratorUc: a.jwtGeneratorUc}
}

func (c *ContextWithToken) UserID() (int, bool) {
    token,_ := GetTokenFromRequest(c.Request())
    userID, err := c.jwtGeneratorUc.ValidateToken(context.TODO(), token)
    if err!= nil {
        return 0, false
    }
    return userID, true
}


func GetTokenFromRequest(req *http.Request) (string, bool) {
	token := req.Header.Get("Authorization")
	return ParseBearerToken(token)
}

func ParseBearerToken(token string) (string, bool) {
	// this fix doubled token (like 'Bearer XXX, Bearer XXX')
	bearers := strings.Split(token, ",")
	token = strings.TrimPrefix(bearers[0], "Bearer ")
	token = strings.TrimPrefix(token, "bearer ")
	//log.Printf("auth token: %s", token)
	if token == "" {
		return "", false
	}
	return token, true
}

var schema = []byte(`{{ .schema }}`)