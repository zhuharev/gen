// Code generated by https://github.com/zhuharev/gen DO NOT EDIT.

package {{ .service.Name }}

import (
    "fmt"
    "context"

    "{{ .project.GoModule }}/domain"
    "{{ .project.GoModule }}/infrastructure"
)

type ReadAccessRulesApplier interface {
    ApplyReadAccessRules(context.Context) error
}

type Repo struct {
    infrastructure.Database

    {{ range .service.Models }}
{{ $model := modelByName $.project . }}
    afterReadList{{ titleName $model.Name }} func(context.Context, *Repo, []domain.{{ titleName $model.Name }}) ([]domain.{{ titleName $model.Name }},error)
    afterRead{{ titleName $model.Name }} func(context.Context, *Repo, *domain.{{ titleName $model.Name }}) (error)
{{ end }}
}

func NewRepo(db infrastructure.Database) *Repo {
    return &Repo{
        Database: db,
    }
}

func (r *Repo) RunInTransaction(ctx context.Context, fn func(context.Context, *Repo) error) error {
    return r.Database.RunInTransaction(ctx, func(ctx context.Context, db infrastructure.Database) error {
        repo := NewRepo(db)
            {{ range .service.Models }}
{{ $model := modelByName $.project . }}
        repo.afterReadList{{ titleName $model.Name }} = r.afterReadList{{ titleName $model.Name }}
        repo.afterRead{{ titleName $model.Name }} = r.afterRead{{ titleName $model.Name }}
        {{ end }}
        return fn(ctx, repo)
    })
}

{{ range .service.Models }}
{{ $model := modelByName $.project . }}
{{ range $model.Columns }}
{{ if isModel $.project .}}
{{ else }}
func (r *Repo) Get{{ titleName $model.Name }}By{{ titleName .Name }}(ctx context.Context, value {{ goType2 $.project . }}) (*domain.{{ titleName $model.Name }}, error) {
    var u domain.{{ titleName $model.Name }}
    err := r.Database.GetByField(ctx, "{{ titleName .Name }}", value, &u)
    if err != nil {
        return nil, fmt.Errorf("get {{$model.Name}} by {{ .Name }}: %w", err)
    }

    if rulesApplier, ok := interface{}(&u).(ReadAccessRulesApplier); ok {
        err := rulesApplier.ApplyReadAccessRules(ctx)
        if err !=nil {
            return nil, err
        }
    }

    if r.afterRead{{ titleName $model.Name }} != nil {
        err = r.afterRead{{ titleName $model.Name }}(ctx, r, &u)
        if err != nil {
            return nil, fmt.Errorf("get callback: %w", err)
        }
    }

    return &u, nil
}
func (r *Repo) List{{ titleName $model.Name }}By{{ titleName .Name }}(ctx context.Context, value {{ goType2 $.project . }}, opts ...infrastructure.ListOptions) ([]domain.{{ titleName $model.Name }}, error) {
    var u []domain.{{ titleName $model.Name }}
    err := r.Database.ListByField(ctx, "{{ titleName .Name }}", value, &u, opts...)
    if err == infrastructure.ErrNotFound {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get list {{$model.Name}} by {{ .Name }}: %w", err)
    }

    if len(u) > 0 {
        if _, ok := interface{}(&u[0]).(ReadAccessRulesApplier); ok {
            for i := range u {
                err := interface{}(&u[i]).(ReadAccessRulesApplier).ApplyReadAccessRules(ctx)
                if err != nil {
                    return nil, err
                }
            }
        }
    }

    if r.afterReadList{{ titleName $model.Name }} != nil {
        u, err = r.afterReadList{{ titleName $model.Name }}(ctx, r, u)
        if err != nil {
            return nil, fmt.Errorf("get list callback: %w", err)
        }
    }

    return u, nil
}
{{end}}
{{ end }}



func (r *Repo) Create{{ titleName . }}(ctx context.Context, model *domain.{{ titleName . }}) error {
    err := r.Database.Create(ctx, model)
    if err != nil {
        return fmt.Errorf("create {{ titleName . }}: %w", err)
    }
    return nil
}

{{ if hasID $model }}
func (r *Repo) Delete{{ titleName . }}(ctx context.Context, id int ) error {
    model := &domain.{{ titleName . }}{ID: id}
    err := r.Database.Delete(ctx, model)
    if err != nil {
        return fmt.Errorf("delete {{ titleName . }}: %w", err)
    }
    return nil
}
{{ end }}

func (r *Repo) Update{{ titleName . }}(ctx context.Context, model *domain.{{ titleName . }}) error {
    err := r.Database.Update(ctx, model)
    if err != nil {
        return fmt.Errorf("update {{ titleName . }}: %w", err)
    }
    return nil
}

func (r *Repo) Update{{ titleName . }}Field(ctx context.Context, model *domain.{{ titleName . }}, field infrastructure.Field, fields ...infrastructure.Field) error {
    err := r.Database.UpdateField(ctx, model, field, fields...)
    if err != nil {
        return fmt.Errorf("update {{ titleName . }}: %w", err)
    }
    return nil
}

func (r *Repo) List{{ titleName . }}(ctx context.Context,opts ...infrastructure.ListOptions) ([]domain.{{ titleName . }}, error) {
    var to []domain.{{ titleName . }}
    err := r.Database.List(ctx, &to, opts...)
    if err == infrastructure.ErrNotFound {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get list of {{ titleName . }} from db: %w", err)
    }

    if len(to) > 0 {
        if _, ok := interface{}(&to[0]).(ReadAccessRulesApplier); ok {
            for i := range to {
                err := interface{}(&to[i]).(ReadAccessRulesApplier).ApplyReadAccessRules(ctx)
                if err != nil {
                    return nil, err
                }
            }
        }
    }

    if r.afterReadList{{ titleName $model.Name }} != nil {
        to, err = r.afterReadList{{ titleName $model.Name }}(ctx, r, to)
        if err != nil {
            return nil, fmt.Errorf("get list callback: %w", err)
        }
    }

    return to, nil
}

func (r *Repo) List{{ titleName . }}ByIDs(ctx context.Context, ids []int, opts ...infrastructure.ListOptions) ([]domain.{{ titleName . }}, error) {
    list, err := r.List{{ titleName .}}ByFields(ctx, []infrastructure.Field{
        {
            Name: r.ColumnByName("ID"),
            Value: ids,
            CompareType: infrastructure.CompareTypeIn,
        },
    })
    if err != nil {
        return nil, err 
    }

    if len(list) > 0 {
        if _, ok := interface{}(&list[0]).(ReadAccessRulesApplier); ok {
            for i := range list {
                err := interface{}(&list[i]).(ReadAccessRulesApplier).ApplyReadAccessRules(ctx)
                if err != nil {
                    return nil, err
                }
            }
        }
    }

    if r.afterReadList{{ titleName $model.Name }} != nil {
        var err error
        list, err = r.afterReadList{{ titleName $model.Name }}(ctx, r, list)
        if err != nil {
            return nil, fmt.Errorf("get list callback: %w", err)
        }
    }    

    return list, nil
}

func (r *Repo) List{{ titleName . }}ByFields(ctx context.Context, fields []infrastructure.Field, opts ...infrastructure.ListOptions) ([]domain.{{ titleName . }}, error) {
    var to []domain.{{ titleName . }}
    err := r.Database.ListByFields(ctx, fields, &to, opts...)
    if err == infrastructure.ErrNotFound {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("get list of {{ titleName . }} from db: %w", err)
    }

    if len(to) > 0 {
        if _, ok := interface{}(&to[0]).(ReadAccessRulesApplier); ok {
            for i := range to {
                err := interface{}(&to[i]).(ReadAccessRulesApplier).ApplyReadAccessRules(ctx)
                if err != nil {
                    return nil, err
                }
            }
        }
    }

    if r.afterReadList{{ titleName $model.Name }} != nil {
        to, err = r.afterReadList{{ titleName $model.Name }}(ctx, r, to)
        if err != nil {
            return nil, fmt.Errorf("get list callback: %w", err)
        }
    }

    return to, nil
}

func (r *Repo) Count{{ titleName . }}ByFields(ctx context.Context, fields []infrastructure.Field) (int, error) {
    var to domain.{{ titleName . }}
    return r.Database.CountByFields(ctx, fields, &to)
}

func (r *Repo) Get{{ titleName . }}ByFields(ctx context.Context, fields []infrastructure.Field) (*domain.{{ titleName . }}, error) {
    var to domain.{{ titleName . }}
    err := r.Database.ListByFields(ctx, fields, &to)
    if err == infrastructure.ErrNotFound {
        return nil, err
    }
    if err != nil {
        return nil, fmt.Errorf("get {{ titleName . }} from db by fields: %w", err)
    }

    if rulesApplier, ok := interface{}(&to).(ReadAccessRulesApplier); ok {
        err := rulesApplier.ApplyReadAccessRules(ctx)
        if err != nil {
            return nil, err
        }
    }

    if r.afterRead{{ titleName $model.Name }} != nil {
        err = r.afterRead{{ titleName $model.Name }}(ctx, r, &to)
        if err != nil {
            return nil, fmt.Errorf("get callback: %w", err)
        }
    }

    return &to, nil
}
{{ end }}

